<?php

declare(strict_types=1);
/**
 * @copyright Copyright (c) 2021 Robin Appelman <robin@icewind.nl>
 *
 * @license GNU AGPL version 3 or any later version
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

namespace OCA\Files_Trashbin\Trash {
	/**
	* @since 15.0.0
	*/
	interface ITrashBackend
	{
		/**
		* List all trash items in the root of the trashbin
		*
		* @return ITrashItem[]
		* @since 15.0.0
		*/
		public function listTrashRoot(\OCP\IUser $user) : array;
		/**
		* List all trash items in a subfolder in the trashbin
		*
		* @return ITrashItem[]
		* @since 15.0.0
		*/
		public function listTrashFolder(\OCA\Files_Trashbin\Trash\ITrashItem $folder) : array;
		/**
		* Restore a trashbin item
		*
		* @since 15.0.0
		*/
		public function restoreItem(\OCA\Files_Trashbin\Trash\ITrashItem $item);
		/**
		* Permanently remove an item from trash
		*
		* @param ITrashItem $item
		* @since 15.0.0
		*/
		public function removeItem(\OCA\Files_Trashbin\Trash\ITrashItem $item);
		/**
		* Move a file or folder to trash
		*
		* @param string $internalPath
		* @return bool whether or not the file was moved to trash, if false then the file should be deleted normally
		* @since 15.0.0
		*/
		public function moveToTrash(\OCP\Files\Storage\IStorage $storage, string $internalPath) : bool;
		/**
		* @param int $fileId
		* @return \OCP\Files\Node|null
		*/
		public function getTrashNodeById(\OCP\IUser $user, int $fileId);
	}
	interface ITrashManager extends \OCA\Files_Trashbin\Trash\ITrashBackend
	{
		/**
		* Add a backend for the trashbin
		*
		* @param string $storageType
		* @param ITrashBackend $backend
		* @since 15.0.0
		*/
		public function registerBackend(string $storageType, \OCA\Files_Trashbin\Trash\ITrashBackend $backend);
		/**
		* List all trash items in the root of the trashbin
		*
		* @return ITrashItem[]
		* @since 15.0.0
		*/
		public function listTrashRoot(\OCP\IUser $user) : array;
		/**
		* Temporally prevent files from being moved to the trash
		*
		* @since 15.0.0
		*/
		public function pauseTrash();
		/**
		* @since 15.0.0
		*/
		public function resumeTrash();
	}
	/**
	* @since 15.0.0
	*/
	interface ITrashItem extends \OCP\Files\FileInfo
	{
		/**
		* Get the trash backend for this item
		*
		* @since 15.0.0
		*/
		public function getTrashBackend() : \OCA\Files_Trashbin\Trash\ITrashBackend;
		/**
		* Get the original location for the trash item
		*
		* @since 15.0.0
		*/
		public function getOriginalLocation() : string;
		/**
		* Get the timestamp that the file was moved to trash
		*
		* @since 15.0.0
		*/
		public function getDeletedTime() : int;
		/**
		* Get the path of the item relative to the users trashbin
		*
		* @since 15.0.0
		*/
		public function getTrashPath() : string;
		/**
		* Whether the item is a deleted item in the root of the trash, or a file in a subfolder
		*
		* @since 15.0.0
		*/
		public function isRootItem() : bool;
		/**
		* Get the user for which this trash item applies
		*
		* @since 15.0.0
		*/
		public function getUser() : \OCP\IUser;
		/**
		* @since 30.0.0
		*/
		public function getDeletedBy() : ?\OCP\IUser;
		public function getTitle() : string;
	}
	class TrashItem implements \OCA\Files_Trashbin\Trash\ITrashItem
	{
		public function __construct(private \OCA\Files_Trashbin\Trash\ITrashBackend $backend, private string $originalLocation, private int $deletedTime, private string $trashPath, private \OCP\Files\FileInfo $fileInfo, private \OCP\IUser $user, private ?\OCP\IUser $deletedBy)
		{
		}
		public function getTrashBackend() : \OCA\Files_Trashbin\Trash\ITrashBackend
		{
		}
		public function getOriginalLocation() : string
		{
		}
		public function getDeletedTime() : int
		{
		}
		public function getTrashPath() : string
		{
		}
		public function isRootItem() : bool
		{
		}
		public function getUser() : \OCP\IUser
		{
		}
		public function getEtag()
		{
		}
		public function getSize($includeMounts = true)
		{
		}
		public function getMtime()
		{
		}
		public function getName()
		{
		}
		public function getInternalPath()
		{
		}
		public function getPath()
		{
		}
		public function getMimetype()
		{
		}
		public function getMimePart()
		{
		}
		public function getStorage()
		{
		}
		public function getId()
		{
		}
		public function isEncrypted()
		{
		}
		public function getPermissions()
		{
		}
		public function getType()
		{
		}
		public function isReadable()
		{
		}
		public function isUpdateable()
		{
		}
		public function isCreatable()
		{
		}
		public function isDeletable()
		{
		}
		public function isShareable()
		{
		}
		public function isShared()
		{
		}
		public function isMounted()
		{
		}
		public function getMountPoint()
		{
		}
		public function getOwner()
		{
		}
		public function getChecksum()
		{
		}
		public function getExtension() : string
		{
		}
		public function getTitle() : string
		{
		}
		public function getCreationTime() : int
		{
		}
		public function getUploadTime() : int
		{
		}
		public function getParentId() : int
		{
		}
		public function getDeletedBy() : ?\OCP\IUser
		{
		}
		/**
		* @inheritDoc
		* @return array<string, int|string|bool|float|string[]|int[]>
		*/
		public function getMetadata() : array
		{
		}
	}
}

namespace OCA\Files\Event {
	/**
	* This event is triggered when the files app is rendered.
	* It can be used to add additional scripts to the files app.
	*
	* @since 17.0.0
	*/
	class LoadAdditionalScriptsEvent extends \OCP\EventDispatcher\Event
	{
		private $hiddenFields = [];
		public function addHiddenField(string $name, string $value) : void
		{
		}
		public function getHiddenFields() : array
		{
		}
	}
}

namespace OCA\Files_Sharing\Event {
	/**
	* Emitted before the rendering step of the public share page happens. The event
	* holds a flag that specifies if it is the authentication page of a public share.
	*
	* @since 20.0.0
	*/
	class BeforeTemplateRenderedEvent extends \OCP\EventDispatcher\Event
	{
		/**
		* @since 20.0.0
		*/
		public const SCOPE_PUBLIC_SHARE_AUTH = 'publicShareAuth';
		/** @var IShare */
		private $share;
		/** @var string|null */
		private $scope;
		/**
		* @since 20.0.0
		*/
		public function __construct(\OCP\Share\IShare $share, ?string $scope = null)
		{
		}
		/**
		* @since 20.0.0
		*/
		public function getShare() : \OCP\Share\IShare
		{
		}
		/**
		* @since 20.0.0
		*/
		public function getScope() : ?string
		{
		}
	}
}


namespace OCA\Files_Trashbin {
	class Expiration
	{
		// how long do we keep files in the trash bin if no other value is defined in the config file (unit: days)
		public const DEFAULT_RETENTION_OBLIGATION = 30;
		public const NO_OBLIGATION = -1;
		public function __construct(\OCP\IConfig $config, \OCP\AppFramework\Utility\ITimeFactory $timeFactory)
		{
		}
		public function setRetentionObligation(string $obligation)
		{
		}
		/**
		* Is trashbin expiration enabled
		* @return bool
		*/
		public function isEnabled()
		{
		}
		/**
		* Check if given timestamp in expiration range
		* @param int $timestamp
		* @param bool $quotaExceeded
		* @return bool
		*/
		public function isExpired($timestamp, $quotaExceeded = false)
		{
		}
		/**
		* @return bool|int
		*/
		public function getMaxAgeAsTimestamp()
		{
		}
		private function parseRetentionObligation()
		{
		}
	}
}

namespace OCA\Files_Versions\Versions {
	use OCP\Files\File;
	use OCP\Files\FileInfo;
	use OCP\Files\NotFoundException;
	use OCP\Files\Storage\IStorage;
	use OCP\IUser;
	use OCP\Files\Node;


	/**
	* @since 15.0.0
	*/
	interface IVersionBackend
	{
		/**
		* Whether or not this version backend should be used for a storage
		*
		* If false is returned then the next applicable backend will be used
		*
		* @param IStorage $storage
		* @return bool
		* @since 17.0.0
		*/
		public function useBackendForStorage(\OCP\Files\Storage\IStorage $storage) : bool;
		/**
		* Get all versions for a file
		*
		* @param IUser $user
		* @param FileInfo $file
		* @return IVersion[]
		* @since 15.0.0
		*/
		public function getVersionsForFile(\OCP\IUser $user, \OCP\Files\FileInfo $file) : array;
		/**
		* Create a new version for a file
		*
		* @param IUser $user
		* @param FileInfo $file
		* @since 15.0.0
		*/
		public function createVersion(\OCP\IUser $user, \OCP\Files\FileInfo $file);
		/**
		* Restore this version
		*
		* @param IVersion $version
		* @since 15.0.0
		*/
		public function rollback(\OCA\Files_Versions\Versions\IVersion $version);
		/**
		* Open the file for reading
		*
		* @param IVersion $version
		* @return resource|false
		* @throws NotFoundException
		* @since 15.0.0
		*/
		public function read(\OCA\Files_Versions\Versions\IVersion $version);
		/**
		* Get the preview for a specific version of a file
		*
		* @param IUser $user
		* @param FileInfo $sourceFile
		* @param int|string $revision
		*
		* @return File
		*
		* @since 15.0.0
		*/
		public function getVersionFile(\OCP\IUser $user, \OCP\Files\FileInfo $sourceFile, $revision) : \OCP\Files\File;
	}

	interface IMetadataVersionBackend {
		public function setMetadataValue(Node $node, int $revision, string $key, string $value): void;
	}

	interface IDeletableVersionBackend {
		public function deleteVersion(IVersion $version): void;
	}

	interface INeedSyncVersionBackend {
		public function createVersionEntity(File $file): void;
		public function updateVersionEntity(File $sourceFile, int $revision, array $properties): void;
		public function deleteVersionsEntity(File $file): void;
	}

	interface IVersion {
		public function getBackend(): IVersionBackend;

		public function getSourceFile(): FileInfo;

		/**
		 * @return int|string
		 */
		public function getRevisionId();

		public function getTimestamp(): int;

		public function getSize(): int;

		public function getSourceFileName(): string;

		public function getMimeType(): string;

		public function getVersionPath(): string;

		public function getUser(): IUser;
	}

	/**
	 * @since 29.0.0
	 */
	interface IVersionsImporterBackend {
		/**
		* Import the given versions for the target file.
		*
		* @param Node $target - The target is not yet created.
		* @param IVersion[] $versions
		* @since 29.0.0
		*/
		public function importVersionsForFile(IUser $user, Node $source, Node $target, array $versions): void;

		/**
		* Clear all versions for a file
		*
		* @since 29.0.0
		*/
		public function clearVersionsForFile(IUser $user, Node $source, Node $target): void;
	}

	/**
	* This interface allows for just direct accessing of the metadata column JSON
	* @since 29.0.0
	*/
	interface IMetadataVersion {
		/**
		* retrieves the all the metadata
		*
		* @return string[]
		* @since 29.0.0
		*/
		public function getMetadata(): array;

		/**
		* retrieves the metadata value from our $key param
		*
		* @param string $key the key for the json value of the metadata column
		* @since 29.0.0
		*/
		public function getMetadataValue(string $key): ?string;
	}

	class Version implements IVersion {
		public function __construct(
			int $timestamp,
			$revisionId,
			string $name,
			int $size,
			string $mimetype,
			string $path,
			FileInfo $sourceFileInfo,
			IVersionBackend $backend,
			IUser $user,
			array $metadata = [],
		) {
		}

		public function getBackend(): IVersionBackend {
			throw new \Exception('stub');
		}

		public function getSourceFile(): FileInfo {
			throw new \Exception('stub');
		}

		public function getRevisionId() {
			throw new \Exception('stub');
		}

		public function getTimestamp(): int {
			throw new \Exception('stub');
		}

		public function getSize(): int {
			throw new \Exception('stub');
		}

		public function getSourceFileName(): string {
			throw new \Exception('stub');
		}

		public function getMimeType(): string {
			throw new \Exception('stub');
		}

		public function getVersionPath(): string {
			throw new \Exception('stub');
		}

		public function getUser(): IUser {
			throw new \Exception('stub');
		}

		public function getMetadataValue(string $key): ?string {
			return $this->metadata[$key] ?? null;
		}
	}
}

namespace OCA\Files_Versions {
	class Expiration {
		// how long do we keep files a version if no other value is defined in the config file (unit: days)
		public const NO_OBLIGATION = -1;
		/** @return bool */
		public function isEnabled() {}

		public function shouldAutoExpire() { }

		/**
		 * @param int $timestamp
		 * @param bool $quotaExceeded
		 * @return bool
		 */
		public function isExpired($timestamp, $quotaExceeded = false) {}

		/** @return int */
		public function getMaxAgeAsTimestamp() {}
	}
}

namespace {

	use OCP\IServerContainer;

	class OC {
		static $CLI = false;
		/** @var IServerContainer */
		static $server;
	}
}

namespace OC\Files\Node {
	use OCP\Files\FileInfo;
	abstract class Node implements \OCP\Files\Node {
		/** @return FileInfo|\ArrayAccess */
		public function getFileInfo() {}

		/** @return \OCP\Files\Mount\IMountPoint */
		public function getMountPoint() {}
	}

	class LazyFolder implements \OCP\Files\Folder {
		public function __construct(\OCP\Files\IRootFolder $rootFolder, \Closure $folderClosure, array $data = []) {
		}
	}
}

namespace OC\Hooks {
	class Emitter {
		public function emit(string $class, string $value, array $option) {}
		/** Closure $closure */
		public function listen(string $class, string $value, $closure) {}
	}
	class BasicEmitter extends Emitter {
	}
}

namespace OC\Cache {
	class CappedMemoryCache {
		public function get($key) {}
		public function set($key, $value, $ttl = '') {}
	}
}

namespace OC\Core\Command {
	use Symfony\Component\Console\Input\InputInterface;
	use Symfony\Component\Console\Output\OutputInterface;
	class Base {
		public const OUTPUT_FORMAT_PLAIN = 'plain';
		public const OUTPUT_FORMAT_JSON = 'json';
		public const OUTPUT_FORMAT_JSON_PRETTY = 'json_pretty';

		public function __construct() {}
		protected function configure() {}
		public function run(InputInterface $input, OutputInterface $output) {}
		public function setName(string $name) {}
		public function getHelper(string $name) {}
		protected function writeArrayInOutputFormat(InputInterface $input, OutputInterface $output, $items, $prefix = '  - ') {
		}
	}
}

namespace OC\Files\ObjectStore {
    use OC\Files\Cache\Scanner;
	class ObjectStoreScanner extends Scanner {}
}

namespace Symfony\Component\Console\Helper {
	use Symfony\Component\Console\Output\OutputInterface;
	class Table {
		public function __construct(OutputInterface $text) {}
		public function setHeaders(array $header) {}
		public function setRows(array $rows) {}
		public function render() {}
	}
}

namespace Symfony\Component\Console\Input {
	class InputInterface {
		public function getOption(string $key) {}
		public function getArgument(string $key) {}
	}
	class InputArgument {
		const REQUIRED = 0;
		const OPTIONAL = 1;
		const IS_ARRAY = 1;
	}
	class InputOption {
		const VALUE_NONE = 1;
		const VALUE_REQUIRED = 1;
	}
}

namespace Symfony\Component\Console\Question {
	class ConfirmationQuestion {
		public function __construct(string $text, bool $default) {}
	}
}

namespace Symfony\Component\Console\Output {
	class OutputInterface {
		public const VERBOSITY_VERBOSE = 1;
		public function writeln(string $text, int $flat = 0) {}
	}
}

namespace OC\Files\Cache {
	use OCP\Files\Cache\ICache;
	use OCP\Files\Cache\IScanner;
	use OCP\Files\Cache\ICacheEntry;
	use OCP\Files\Search\ISearchQuery;
	use OCP\Files\Search\ISearchOperator;
	use OCP\Files\Search\ISearchQuery;
	use OCP\Files\IMimeTypeLoader;
	use OCP\Files\Storage\IStorage;

	class Cache implements ICache {
		/**
		 * @param \OCP\Files\Cache\ICache $cache
		 */
		public function __construct($cache) {
			$this->cache = $cache;
		}
		public function getNumericStorageId() { }
		public function get() { }
		public function getIncomplete() {}
		public function getPathById($id) {}
		public function getAll() {}
		public function get($file) {}
		public function getFolderContents($folder) {}
		public function getFolderContentsById($fileId) {}
		public function put($file, array $data) {}
		public function insert($file, array $data) {}
		public function update($id, array $data) {}
		public function getId($file) {}
		public function getParentId($file) {}
		public function inCache($file) {}
		public function remove($file) {}
		public function move($source, $target) {}
		public function moveFromCache(ICache $sourceCache, $sourcePath, $targetPath) {}
		public function clear() {}
		public function getStatus($file) {}
		public function search($pattern) {}
		public function searchByMime($mimetype) {}
		public function searchQuery(ISearchQuery $query) {}
		public function correctFolderSize($path, $data = null, $isBackgroundScan = false) {}
		public function copyFromCache(ICache $sourceCache, ICacheEntry $sourceEntry, string $targetPath): int {}
		public function normalize($path) {}
		public function getQueryFilterForStorage(): ISearchOperator {}
		public function getCacheEntryFromSearchResult(ICacheEntry $rawEntry): ?ICacheEntry {}
		public static function cacheEntryFromData($data, IMimeTypeLoader $mimetypeLoader): ICacheEntry {}
	}

    class Scanner implements IScanner {
        public function __construct(IStorage $storage) {}
    }
}

namespace OC\Files\Cache\Wrapper {
	use OC\Files\Cache\Cache;
	use OCP\Files\Cache\ICache;

	class CacheWrapper extends Cache {
        public function getCache(): Cache {}
	}

	class CacheJail extends CacheWrapper {
		public function __construct(?ICache $cache, string $root, ?CacheDependencies $dependencies = null) {}
	}
}

namespace OC\Files {
	use OCP\Files\Cache\ICacheEntry;
	use OCP\Files\Mount\IMountPoint;
	use OCP\IUser;

	class Filesystem {
		public static function addStorageWrapper(string $wrapperName, callable $wrapper, int $priority = 50) {
		}

		public static function getView(string $root): View {
		}
	}

	class FileInfo implements \OCP\Files\FileInfo {
		/**
		 * @param string|boolean $path
		 * @param \OCP\Files\Storage\IStorage $storage
		 * @param string $internalPath
		 * @param array|ICacheEntry $data
		 * @param \OCP\Files\Mount\IMountPoint $mount
		 * @param \OCP\IUser|null $owner
		 */
		public function __construct($path, $storage, $internalPath, $data, $mount, $owner = null) {}
	}
	class View {
		public function __construct(string $path) {}
		public function unlink($path) {}
	}
}

namespace OC\User {
	use OCP\EventDispatcher\IEventDispatcher;
	use OCP\IUser;
	use OCP\UserInterface;

	class User implements IUser {
		public function __construct(string $uid, ?UserInterface $backend, IEventDispatcher $dispatcher, $emitter = null, IConfig $config = null, $urlGenerator = null) {}
	}
}

namespace OCA\DAV\Upload {

	use Sabre\DAV\File;

	abstract class FutureFile extends File {}
}

namespace OCA\DAV\Connector\Sabre {

	class Node {
		public function getFileInfo(): \OCP\Files\FileInfo {}
	}
}

namespace OCA\DAV\Connector\Sabre {

	use OCP\Files\FileInfo;

	class Principal {}

	class Directory extends \Sabre\DAV\Node {


		public function __construct(\OC\Files\View $view, FileInfo $info) {
		}

		function getChild(string $name): \Sabre\DAV\Node {
		}
		public function delete() {
		}
		public function getLastModified() {
		}
		public function setName($name) {
		}
		public function getName() {
		}
		public function getFileInfo(): FileInfo {
		}
	}
}

namespace OC\BackgroundJob {

	use OCP\BackgroundJob\IJob;
	use OCP\BackgroundJob\IJobList;
	use OCP\ILogger;

	abstract class TimedJob implements IJob {
		public function execute(IJobList $jobList, ILogger $logger = null) {
		}

		abstract protected function run($argument);

		public function setId(int $id) {
		}

		public function setLastRun(int $lastRun) {
		}

		public function setArgument($argument) {
		}

		public function getId() {
		}

		public function getLastRun() {
		}

		public function getArgument() {
		}
	}
}

namespace OC\Files\Mount {
	use OC\Files\Filesystem;
	use OC\Files\Storage\Storage;
	use OC\Files\Storage\StorageFactory;
	use OCP\Files\Mount\IMountPoint;

	class MountPoint implements IMountPoint {
		/**
		 * @var \OCP\Files\Storage\IStorage $storage
		 */
		protected $storage = null;
		protected $class;
		protected $storageId;
		protected $rootId = null;

		/** @var int|null */
		protected $mountId;

		/**
		 * @param string|\OCP\Files\Storage\IStorage $storage
		 * @param string $mountpoint
		 * @param array $arguments (optional) configuration for the storage backend
		 * @param \OCP\Files\Storage\IStorageFactory $loader
		 * @param array $mountOptions mount specific options
		 * @param int|null $mountId
		 * @throws \Exception
		 */
		public function __construct($storage, $mountpoint, $arguments = null, $loader = null, $mountOptions = null, $mountId = null, string $mountProvider = null) {
			throw new \Exception('stub');
		}

		/**
		 * get complete path to the mount point, relative to data/
		 *
		 * @return string
		 */
		public function getMountPoint() {
			throw new \Exception('stub');
		}

		/**
		 * Sets the mount point path, relative to data/
		 *
		 * @param string $mountPoint new mount point
		 */
		public function setMountPoint($mountPoint) {
			throw new \Exception('stub');
		}

		/**
		 * @return \OCP\Files\Storage\IStorage
		 */
		public function getStorage() {
			throw new \Exception('stub');
		}

		/**
		 * @return string
		 */
		public function getStorageId() {
			throw new \Exception('stub');
		}

		/**
		 * @return int
		 */
		public function getNumericStorageId() {
			throw new \Exception('stub');
		}

		/**
		 * @param string $path
		 * @return string
		 */
		public function getInternalPath($path) {
			throw new \Exception('stub');
		}

		/**
		 * @param callable $wrapper
		 */
		public function wrapStorage($wrapper) {
			throw new \Exception('stub');
		}

		/**
		 * Get a mount option
		 *
		 * @param string $name Name of the mount option to get
		 * @param mixed $default Default value for the mount option
		 * @return mixed
		 */
		public function getOption($name, $default) {
			throw new \Exception('stub');
		}

		/**
		 * Get all options for the mount
		 *
		 * @return array
		 */
		public function getOptions() {
			throw new \Exception('stub');
		}

		/**
		 * @return int
		 */
		public function getStorageRootId() {
			throw new \Exception('stub');
		}

		public function getMountId() {
			throw new \Exception('stub');
		}

		public function getMountType() {
			throw new \Exception('stub');
		}

		public function getMountProvider(): string {
			throw new \Exception('stub');
		}
	}
}

namespace OC\Files\Storage {
	/**
	* Provide a common interface to all different storage options
	*
	* All paths passed to the storage are relative to the storage and should NOT have a leading slash.
	*/
	interface Storage extends \OCP\Files\Storage
	{
		/**
		* get a cache instance for the storage
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage|null (optional) the storage to pass to the cache
		* @return \OC\Files\Cache\Cache
		*/
		public function getCache($path = '', $storage = null);
		/**
		* get a scanner instance for the storage
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage (optional) the storage to pass to the scanner
		* @return \OC\Files\Cache\Scanner
		*/
		public function getScanner($path = '', $storage = null);
		/**
		* get the user id of the owner of a file or folder
		*
		* @param string $path
		* @return string
		*/
		public function getOwner($path);
		/**
		* get a watcher instance for the cache
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage (optional) the storage to pass to the watcher
		* @return \OC\Files\Cache\Watcher
		*/
		public function getWatcher($path = '', $storage = null);
		/**
		* get a propagator instance for the cache
		*
		* @param \OC\Files\Storage\Storage (optional) the storage to pass to the watcher
		* @return \OC\Files\Cache\Propagator
		*/
		public function getPropagator($storage = null);
		/**
		* get a updater instance for the cache
		*
		* @param \OC\Files\Storage\Storage (optional) the storage to pass to the watcher
		* @return \OC\Files\Cache\Updater
		*/
		public function getUpdater($storage = null);
		/**
		* @return \OC\Files\Cache\Storage
		*/
		public function getStorageCache();
		/**
		* @param string $path
		* @return array|null
		*/
		public function getMetaData($path);
		/**
		* @param string $path The path of the file to acquire the lock for
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		* @throws \OCP\Lock\LockedException
		*/
		public function acquireLock($path, $type, \OCP\Lock\ILockingProvider $provider);
		/**
		* @param string $path The path of the file to release the lock for
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		* @throws \OCP\Lock\LockedException
		*/
		public function releaseLock($path, $type, \OCP\Lock\ILockingProvider $provider);
		/**
		* @param string $path The path of the file to change the lock for
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		* @throws \OCP\Lock\LockedException
		*/
		public function changeLock($path, $type, \OCP\Lock\ILockingProvider $provider);
		/**
		* Get the contents of a directory with metadata
		*
		* @param string $directory
		* @return \Traversable an iterator, containing file metadata
		*
		* The metadata array will contain the following fields
		*
		* - name
		* - mimetype
		* - mtime
		* - size
		* - etag
		* - storage_mtime
		* - permissions
		*/
		public function getDirectoryContent($directory) : \Traversable;
	}
}

namespace OC\Files\Storage\Wrapper{
	use OCP\Files\Storage\IStorage;

	class Wrapper implements \OC\Files\Storage\Storage, \OCP\Files\Storage\ILockingStorage, \OCP\Files\Storage\IWriteStreamStorage
	{
		/**
		* @var \OC\Files\Storage\Storage $storage
		*/
		protected $storage;
		public $cache;
		public $scanner;
		public $watcher;
		public $propagator;
		public $updater;
		/**
		* @param array $parameters
		*/
		public function __construct($parameters)
		{
		}
		/**
		* @return \OC\Files\Storage\Storage
		*/
		public function getWrapperStorage()
		{
		}
		/**
		* Get the identifier for the storage,
		* the returned id should be the same for every storage object that is created with the same parameters
		* and two storage objects with the same id should refer to two storages that display the same files.
		*
		* @return string
		*/
		public function getId()
		{
		}
		/**
		* see https://www.php.net/manual/en/function.mkdir.php
		*
		* @param string $path
		* @return bool
		*/
		public function mkdir($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.rmdir.php
		*
		* @param string $path
		* @return bool
		*/
		public function rmdir($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.opendir.php
		*
		* @param string $path
		* @return resource|false
		*/
		public function opendir($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.is_dir.php
		*
		* @param string $path
		* @return bool
		*/
		public function is_dir($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.is_file.php
		*
		* @param string $path
		* @return bool
		*/
		public function is_file($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.stat.php
		* only the following keys are required in the result: size and mtime
		*
		* @param string $path
		* @return array|bool
		*/
		public function stat($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.filetype.php
		*
		* @param string $path
		* @return string|bool
		*/
		public function filetype($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.filesize.php
		* The result for filesize when called on a folder is required to be 0
		*/
		public function filesize($path) : false|int|float
		{
		}
		/**
		* check if a file can be created in $path
		*
		* @param string $path
		* @return bool
		*/
		public function isCreatable($path)
		{
		}
		/**
		* check if a file can be read
		*
		* @param string $path
		* @return bool
		*/
		public function isReadable($path)
		{
		}
		/**
		* check if a file can be written to
		*
		* @param string $path
		* @return bool
		*/
		public function isUpdatable($path)
		{
		}
		/**
		* check if a file can be deleted
		*
		* @param string $path
		* @return bool
		*/
		public function isDeletable($path)
		{
		}
		/**
		* check if a file can be shared
		*
		* @param string $path
		* @return bool
		*/
		public function isSharable($path)
		{
		}
		/**
		* get the full permissions of a path.
		* Should return a combination of the PERMISSION_ constants defined in lib/public/constants.php
		*
		* @param string $path
		* @return int
		*/
		public function getPermissions($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.file_exists.php
		*
		* @param string $path
		* @return bool
		*/
		public function file_exists($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.filemtime.php
		*
		* @param string $path
		* @return int|bool
		*/
		public function filemtime($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.file_get_contents.php
		*
		* @param string $path
		* @return string|false
		*/
		public function file_get_contents($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.file_put_contents.php
		*
		* @param string $path
		* @param mixed $data
		* @return int|float|false
		*/
		public function file_put_contents($path, $data)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.unlink.php
		*
		* @param string $path
		* @return bool
		*/
		public function unlink($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.rename.php
		*
		* @param string $source
		* @param string $target
		* @return bool
		*/
		public function rename($source, $target)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.copy.php
		*
		* @param string $source
		* @param string $target
		* @return bool
		*/
		public function copy($source, $target)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.fopen.php
		*
		* @param string $path
		* @param string $mode
		* @return resource|bool
		*/
		public function fopen($path, $mode)
		{
		}
		/**
		* get the mimetype for a file or folder
		* The mimetype for a folder is required to be "httpd/unix-directory"
		*
		* @param string $path
		* @return string|bool
		*/
		public function getMimeType($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.hash.php
		*
		* @param string $type
		* @param string $path
		* @param bool $raw
		* @return string|bool
		*/
		public function hash($type, $path, $raw = false)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.free_space.php
		*
		* @param string $path
		* @return int|float|bool
		*/
		public function free_space($path)
		{
		}
		/**
		* search for occurrences of $query in file names
		*
		* @param string $query
		* @return array|bool
		*/
		public function search($query)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.touch.php
		* If the backend does not support the operation, false should be returned
		*
		* @param string $path
		* @param int $mtime
		* @return bool
		*/
		public function touch($path, $mtime = null)
		{
		}
		/**
		* get the path to a local version of the file.
		* The local version of the file can be temporary and doesn't have to be persistent across requests
		*
		* @param string $path
		* @return string|false
		*/
		public function getLocalFile($path)
		{
		}
		/**
		* check if a file or folder has been updated since $time
		*
		* @param string $path
		* @param int $time
		* @return bool
		*
		* hasUpdated for folders should return at least true if a file inside the folder is add, removed or renamed.
		* returning true for other changes in the folder is optional
		*/
		public function hasUpdated($path, $time)
		{
		}
		/**
		* get a cache instance for the storage
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage|null (optional) the storage to pass to the cache
		* @return \OC\Files\Cache\Cache
		*/
		public function getCache($path = '', $storage = null)
		{
		}
		/**
		* get a scanner instance for the storage
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage (optional) the storage to pass to the scanner
		* @return \OC\Files\Cache\Scanner
		*/
		public function getScanner($path = '', $storage = null)
		{
		}
		/**
		* get the user id of the owner of a file or folder
		*
		* @param string $path
		* @return string
		*/
		public function getOwner($path)
		{
		}
		/**
		* get a watcher instance for the cache
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage (optional) the storage to pass to the watcher
		* @return \OC\Files\Cache\Watcher
		*/
		public function getWatcher($path = '', $storage = null)
		{
		}
		public function getPropagator($storage = null)
		{
		}
		public function getUpdater($storage = null)
		{
		}
		/**
		* @return \OC\Files\Cache\Storage
		*/
		public function getStorageCache()
		{
		}
		/**
		* get the ETag for a file or folder
		*
		* @param string $path
		* @return string|false
		*/
		public function getETag($path)
		{
		}
		/**
		* Returns true
		*
		* @return true
		*/
		public function test()
		{
		}
		/**
		* Returns the wrapped storage's value for isLocal()
		*
		* @return bool wrapped storage's isLocal() value
		*/
		public function isLocal()
		{
		}
		/**
		* Check if the storage is an instance of $class or is a wrapper for a storage that is an instance of $class
		*
		* @param class-string<IStorage> $class
		* @return bool
		*/
		public function instanceOfStorage($class)
		{
		}
		/**
		* @psalm-template T of IStorage
		* @psalm-param class-string<T> $class
		* @psalm-return T|null
		*/
		public function getInstanceOfStorage(string $class)
		{
		}
		/**
		* Pass any methods custom to specific storage implementations to the wrapped storage
		*
		* @param string $method
		* @param array $args
		* @return mixed
		*/
		public function __call($method, $args)
		{
		}
		/**
		* A custom storage implementation can return an url for direct download of a give file.
		*
		* For now the returned array can hold the parameter url - in future more attributes might follow.
		*
		* @param string $path
		* @return array|bool
		*/
		public function getDirectDownload($path)
		{
		}
		/**
		* Get availability of the storage
		*
		* @return array [ available, last_checked ]
		*/
		public function getAvailability()
		{
		}
		/**
		* Set availability of the storage
		*
		* @param bool $isAvailable
		*/
		public function setAvailability($isAvailable)
		{
		}
		/**
		* @param string $path the path of the target folder
		* @param string $fileName the name of the file itself
		* @return void
		* @throws InvalidPathException
		*/
		public function verifyPath($path, $fileName)
		{
		}
		/**
		* @param IStorage $sourceStorage
		* @param string $sourceInternalPath
		* @param string $targetInternalPath
		* @return bool
		*/
		public function copyFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, $sourceInternalPath, $targetInternalPath)
		{
		}
		/**
		* @param IStorage $sourceStorage
		* @param string $sourceInternalPath
		* @param string $targetInternalPath
		* @return bool
		*/
		public function moveFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, $sourceInternalPath, $targetInternalPath)
		{
		}
		public function getMetaData($path)
		{
		}
		/**
		* @param string $path
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		* @throws \OCP\Lock\LockedException
		*/
		public function acquireLock($path, $type, \OCP\Lock\ILockingProvider $provider)
		{
		}
		/**
		* @param string $path
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		*/
		public function releaseLock($path, $type, \OCP\Lock\ILockingProvider $provider)
		{
		}
		/**
		* @param string $path
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		*/
		public function changeLock($path, $type, \OCP\Lock\ILockingProvider $provider)
		{
		}
		/**
		* @return bool
		*/
		public function needsPartFile()
		{
		}
		public function writeStream(string $path, $stream, ?int $size = null) : int
		{
		}
		public function getDirectoryContent($directory) : \Traversable
		{
		}
		public function isWrapperOf(\OCP\Files\Storage\IStorage $storage)
		{
		}
		public function setOwner(?string $user) : void
		{
		}
	}
	/**
	* Jail to a subdirectory of the wrapped storage
	*
	* This restricts access to a subfolder of the wrapped storage with the subfolder becoming the root folder new storage
	*/
	class Jail extends \OC\Files\Storage\Wrapper\Wrapper
	{
		/**
		* @var string
		*/
		protected $rootPath;
		/**
		* @param array $arguments ['storage' => $storage, 'root' => $root]
		*
		* $storage: The storage that will be wrapper
		* $root: The folder in the wrapped storage that will become the root folder of the wrapped storage
		*/
		public function __construct($arguments)
		{
		}
		public function getUnjailedPath($path)
		{
		}
		/**
		* This is separate from Wrapper::getWrapperStorage so we can get the jailed storage consistently even if the jail is inside another wrapper
		*/
		public function getUnjailedStorage()
		{
		}
		public function getJailedPath($path)
		{
		}
		public function getId()
		{
		}
		/**
		* see https://www.php.net/manual/en/function.mkdir.php
		*
		* @param string $path
		* @return bool
		*/
		public function mkdir($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.rmdir.php
		*
		* @param string $path
		* @return bool
		*/
		public function rmdir($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.opendir.php
		*
		* @param string $path
		* @return resource|false
		*/
		public function opendir($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.is_dir.php
		*
		* @param string $path
		* @return bool
		*/
		public function is_dir($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.is_file.php
		*
		* @param string $path
		* @return bool
		*/
		public function is_file($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.stat.php
		* only the following keys are required in the result: size and mtime
		*
		* @param string $path
		* @return array|bool
		*/
		public function stat($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.filetype.php
		*
		* @param string $path
		* @return bool
		*/
		public function filetype($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.filesize.php
		* The result for filesize when called on a folder is required to be 0
		*/
		public function filesize($path) : false|int|float
		{
		}
		/**
		* check if a file can be created in $path
		*
		* @param string $path
		* @return bool
		*/
		public function isCreatable($path)
		{
		}
		/**
		* check if a file can be read
		*
		* @param string $path
		* @return bool
		*/
		public function isReadable($path)
		{
		}
		/**
		* check if a file can be written to
		*
		* @param string $path
		* @return bool
		*/
		public function isUpdatable($path)
		{
		}
		/**
		* check if a file can be deleted
		*
		* @param string $path
		* @return bool
		*/
		public function isDeletable($path)
		{
		}
		/**
		* check if a file can be shared
		*
		* @param string $path
		* @return bool
		*/
		public function isSharable($path)
		{
		}
		/**
		* get the full permissions of a path.
		* Should return a combination of the PERMISSION_ constants defined in lib/public/constants.php
		*
		* @param string $path
		* @return int
		*/
		public function getPermissions($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.file_exists.php
		*
		* @param string $path
		* @return bool
		*/
		public function file_exists($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.filemtime.php
		*
		* @param string $path
		* @return int|bool
		*/
		public function filemtime($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.file_get_contents.php
		*
		* @param string $path
		* @return string|false
		*/
		public function file_get_contents($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.file_put_contents.php
		*
		* @param string $path
		* @param mixed $data
		* @return int|float|false
		*/
		public function file_put_contents($path, $data)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.unlink.php
		*
		* @param string $path
		* @return bool
		*/
		public function unlink($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.rename.php
		*
		* @param string $source
		* @param string $target
		* @return bool
		*/
		public function rename($source, $target)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.copy.php
		*
		* @param string $source
		* @param string $target
		* @return bool
		*/
		public function copy($source, $target)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.fopen.php
		*
		* @param string $path
		* @param string $mode
		* @return resource|bool
		*/
		public function fopen($path, $mode)
		{
		}
		/**
		* get the mimetype for a file or folder
		* The mimetype for a folder is required to be "httpd/unix-directory"
		*
		* @param string $path
		* @return string|bool
		*/
		public function getMimeType($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.hash.php
		*
		* @param string $type
		* @param string $path
		* @param bool $raw
		* @return string|bool
		*/
		public function hash($type, $path, $raw = false)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.free_space.php
		*
		* @param string $path
		* @return int|float|bool
		*/
		public function free_space($path)
		{
		}
		/**
		* search for occurrences of $query in file names
		*
		* @param string $query
		* @return array|bool
		*/
		public function search($query)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.touch.php
		* If the backend does not support the operation, false should be returned
		*
		* @param string $path
		* @param int $mtime
		* @return bool
		*/
		public function touch($path, $mtime = null)
		{
		}
		/**
		* get the path to a local version of the file.
		* The local version of the file can be temporary and doesn't have to be persistent across requests
		*
		* @param string $path
		* @return string|false
		*/
		public function getLocalFile($path)
		{
		}
		/**
		* check if a file or folder has been updated since $time
		*
		* @param string $path
		* @param int $time
		* @return bool
		*
		* hasUpdated for folders should return at least true if a file inside the folder is add, removed or renamed.
		* returning true for other changes in the folder is optional
		*/
		public function hasUpdated($path, $time)
		{
		}
		/**
		* get a cache instance for the storage
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage|null (optional) the storage to pass to the cache
		* @return \OC\Files\Cache\Cache
		*/
		public function getCache($path = '', $storage = null)
		{
		}
		/**
		* get the user id of the owner of a file or folder
		*
		* @param string $path
		* @return string
		*/
		public function getOwner($path)
		{
		}
		/**
		* get a watcher instance for the cache
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage (optional) the storage to pass to the watcher
		* @return \OC\Files\Cache\Watcher
		*/
		public function getWatcher($path = '', $storage = null)
		{
		}
		/**
		* get the ETag for a file or folder
		*
		* @param string $path
		* @return string|false
		*/
		public function getETag($path)
		{
		}
		public function getMetaData($path)
		{
		}
		/**
		* @param string $path
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		* @throws \OCP\Lock\LockedException
		*/
		public function acquireLock($path, $type, \OCP\Lock\ILockingProvider $provider)
		{
		}
		/**
		* @param string $path
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		*/
		public function releaseLock($path, $type, \OCP\Lock\ILockingProvider $provider)
		{
		}
		/**
		* @param string $path
		* @param int $type \OCP\Lock\ILockingProvider::LOCK_SHARED or \OCP\Lock\ILockingProvider::LOCK_EXCLUSIVE
		* @param \OCP\Lock\ILockingProvider $provider
		*/
		public function changeLock($path, $type, \OCP\Lock\ILockingProvider $provider)
		{
		}
		/**
		* Resolve the path for the source of the share
		*
		* @param string $path
		* @return array
		*/
		public function resolvePath($path)
		{
		}
		/**
		* @param IStorage $sourceStorage
		* @param string $sourceInternalPath
		* @param string $targetInternalPath
		* @return bool
		*/
		public function copyFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, $sourceInternalPath, $targetInternalPath)
		{
		}
		/**
		* @param IStorage $sourceStorage
		* @param string $sourceInternalPath
		* @param string $targetInternalPath
		* @return bool
		*/
		public function moveFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, $sourceInternalPath, $targetInternalPath)
		{
		}
		public function getPropagator($storage = null)
		{
		}
		public function writeStream(string $path, $stream, ?int $size = null) : int
		{
		}
		public function getDirectoryContent($directory) : \Traversable
		{
		}
	}
	class Quota extends \OC\Files\Storage\Wrapper\Wrapper
	{
		/** @var callable|null */
		protected $quotaCallback;
		/** @var int|float|null int on 64bits, float on 32bits for bigint */
		protected int|float|null $quota;
		protected string $sizeRoot;
		private \OC\SystemConfig $config;
		private bool $quotaIncludeExternalStorage;
		/**
		* @param array $parameters
		*/
		public function __construct($parameters)
		{
		}
		/**
		* @return int|float quota value
		*/
		public function getQuota() : int|float
		{
		}
		private function hasQuota() : bool
		{
		}
		/**
		* @param string $path
		* @param IStorage $storage
		* @return int|float
		*/
		protected function getSize($path, $storage = null)
		{
		}
		/**
		* Get free space as limited by the quota
		*
		* @param string $path
		* @return int|float|bool
		*/
		public function free_space($path)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.file_put_contents.php
		*
		* @param string $path
		* @param mixed $data
		* @return int|float|false
		*/
		public function file_put_contents($path, $data)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.copy.php
		*
		* @param string $source
		* @param string $target
		* @return bool
		*/
		public function copy($source, $target)
		{
		}
		/**
		* see https://www.php.net/manual/en/function.fopen.php
		*
		* @param string $path
		* @param string $mode
		* @return resource|bool
		*/
		public function fopen($path, $mode)
		{
		}
		/**
		* Checks whether the given path is a part file
		*
		* @param string $path Path that may identify a .part file
		* @return bool
		* @note this is needed for reusing keys
		*/
		private function isPartFile($path)
		{
		}
		/**
		* Only apply quota for files, not metadata, trash or others
		*/
		private function shouldApplyQuota(string $path) : bool
		{
		}
		/**
		* @param IStorage $sourceStorage
		* @param string $sourceInternalPath
		* @param string $targetInternalPath
		* @return bool
		*/
		public function copyFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, $sourceInternalPath, $targetInternalPath)
		{
		}
		/**
		* @param IStorage $sourceStorage
		* @param string $sourceInternalPath
		* @param string $targetInternalPath
		* @return bool
		*/
		public function moveFromStorage(\OCP\Files\Storage\IStorage $sourceStorage, $sourceInternalPath, $targetInternalPath)
		{
		}
		public function mkdir($path)
		{
		}
		public function touch($path, $mtime = null)
		{
		}
	}
	/**
	* Mask the permissions of a storage
	*
	* This can be used to restrict update, create, delete and/or share permissions of a storage
	*
	* Note that the read permissions can't be masked
	*/
	class PermissionsMask extends \OC\Files\Storage\Wrapper\Wrapper
	{
		/**
		* @var int the permissions bits we want to keep
		*/
		private $mask;
		/**
		* @param array $arguments ['storage' => $storage, 'mask' => $mask]
		*
		* $storage: The storage the permissions mask should be applied on
		* $mask: The permission bits that should be kept, a combination of the \OCP\Constant::PERMISSION_ constants
		*/
		public function __construct($arguments)
		{
		}
		private function checkMask($permissions)
		{
		}
		public function isUpdatable($path)
		{
		}
		public function isCreatable($path)
		{
		}
		public function isDeletable($path)
		{
		}
		public function isSharable($path)
		{
		}
		public function getPermissions($path)
		{
		}
		public function rename($source, $target)
		{
		}
		public function copy($source, $target)
		{
		}
		public function touch($path, $mtime = null)
		{
		}
		public function mkdir($path)
		{
		}
		public function rmdir($path)
		{
		}
		public function unlink($path)
		{
		}
		public function file_put_contents($path, $data)
		{
		}
		public function fopen($path, $mode)
		{
		}
		/**
		* get a cache instance for the storage
		*
		* @param string $path
		* @param \OC\Files\Storage\Storage (optional) the storage to pass to the cache
		* @return \OC\Files\Cache\Cache
		*/
		public function getCache($path = '', $storage = null)
		{
		}
		public function getMetaData($path)
		{
		}
		public function getScanner($path = '', $storage = null)
		{
		}
		public function getDirectoryContent($directory) : \Traversable
		{
		}
	}
}

namespace OC\Files\ObjectStore {
    use OC\Files\Storage\Wrapper\Wrapper;
    class ObjectStoreStorage extends Wrapper {}
}

namespace OCA\Circles {
	use OCA\Circles\Model\Circle;
	use OCA\Circles\Model\FederatedUser;
	use OCA\Circles\Model\Probes\CircleProbe;
	use OCA\Circles\Model\Probes\DataProbe;
	use OCP\DB\QueryBuilder\ICompositeExpression;
	use OCP\DB\QueryBuilder\IQueryBuilder;

	interface IFederatedUser {

	}

	class CirclesManager {
		public function startSession(?FederatedUser $federatedUser = null): void {}
		public function probeCircles(?CircleProbe $circleProbe = null, ?DataProbe $dataProbe = null): array {}
		public function getQueryHelper(): CirclesQueryHelper {}
		public function getLocalFederatedUser(string $userId): FederatedUser {}
		public function startSuperSession(): void {}
		public function stopSession(): void {}
		public function getCircle(string $singleId, ?CircleProbe $probe = null): Circle {}
	}

	class CirclesQueryHelper{
		public function addCircleDetails(string $alias, string $field): void {}
		public function getQueryBuilder(): IQueryBuilder {}
		public function extractCircle(array $data): Circle {}
		public function limitToInheritedMembers(string $alias, string $field, IFederatedUser $federatedUser, bool $fullDetails = false): ICompositeExpression {}
	}
}

namespace OCA\Circles\Exceptions {
	class CircleNotFoundException extends \Exception {
	}
}

namespace OCA\Circles\Model {
	use OCA\Circles\IFederatedUser;

	class FederatedUser implements IFederatedUser {
	}
	class CircleProbe {
	}
	class DataProbe {
	}
	class Circle {
		public function getDisplayName(): string {}
		public function getSingleId(): string {}
	}
}

namespace OCA\Circles\Model\Probes {
	class CircleProbe {
		public function includeSystemCircles(bool $include = true): self {}
		public function includeSingleCircles(bool $include = true): self {}
	}
}

namespace OCA\Circles\Events {
	use OCA\Circles\Model\Circle;

	class CircleDestroyedEvent extends \OCP\EventDispatcher\Event {
		public function getCircle(): Circle {}
	}
}


namespace OCA\DAV\Connector\Sabre\Exception {
	class Forbidden extends \Sabre\DAV\Exception\Forbidden {
		public const NS_OWNCLOUD = 'http://owncloud.org/ns';

		/**
		* @param string $message
		* @param bool $retry
		* @param \Exception $previous
		*/
		public function __construct($message, $retry = false, \Exception $previous = null) {}

		/**
		* This method allows the exception to include additional information
		* into the WebDAV error response
		*
		* @param \Sabre\DAV\Server $server
		* @param \DOMElement $errorNode
		* @return void
		*/
		public function serialize(\Sabre\DAV\Server $server, \DOMElement $errorNode) {}
	}
}
